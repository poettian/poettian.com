{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"关于我👉 资深游戏迷，喜欢各种球类运动，酷爱各种电子设备，没事爱折腾，经常逛微博、偶尔去知乎、朋友圈基本只看不发、Twitter有账号。 👉 目前从事web开发工作，从12年开始学习编程，主要用 php 做后端开发，正在学习C和GO，技术上仍是菜鸟一枚，属于大龄IT男。","link":"/about/index.html"}],"posts":[{"title":"PHP的数据类型","text":"学习一门语言，数据类型是必须要首先了解的。php 作为一种弱类型语言，数据类型的特点和不经意间的类型转换，往往是入坑的关键。 查看和验证数据的类型如果想查看某个表达式的值和类型，用 var_dump() 函数。 如果只是想得到一个易读懂的类型的表达方式用于调试，用 gettype() 函数。要检验某个类型，不要用 gettype()，而用 is_type 函数。 浮点数PHP 中不区分 float 和 double，如果需要高精度的计算，应该使用 BC 数学函数 或 gmp函数。 理解计算机是如何存储浮点类型数据的 字符串PHP 中的 string 的实现方式是一个由字节组成的数组再加上一个整数指明缓冲区长度。 编码字符串会被按照该脚本文件相同的编码方式来编码。我们知道，一般脚本文件都是以utf-8编码的，那么我们就来看一看字符串（英文和中文）到底在php中是如何存储的。 我们知道以utf8编码的一个字符占用1-4个字节，英文字符占用一个字节，中文字符一般占用3个字节。而由定义可知，字符串的内容是存在字节数组中的，所以字符串实际存储是以字节为单位的。 举个例子，比如：$str = 'abc严肃'。英文 abc 是单字节字符，对应的字节是 0x61 0x62 0x63，中文 严肃 是多字节字符，对应的字节分别是 0xe4 0xb8 0xa5 0xe8 0x82 0x83。（此处可参考：字符编码笔记：ASCII，Unicode 和 UTF-8） 所以字符串 $str 实际的存储如图所示： 但我们使用单字节函数时，就会得到以下结果： 123$str = 'abc严肃'echo strlen($str); // output: 9echo substr($str, 3, 1); // output：�，也许我们的本意是想取得‘严’这个字符，但是因为结果实际是取到了 0xe4 这个字节，但是无法以utf8反编码，只能是显示为乱码 其实这也解释了，为什么我们可以直接对中文字符串使用 ‘==’ 进行比较，因为比较是基于字节进行的。 与c语言字符串的区别：在c语言中，字符串是以一个空字符 \\0 结尾的，但是在php中，其值为 0（“NUL bytes”）的字节可以处于字符串任何位置。那php中如何界定字符串的结尾呢？这依赖于字符串的特殊结构： 12345678910111213/*gc: 变量引用信息,比如当前value的引用数,所有用到引用计数的变量类型都会有这个结构,3.1节会详细分析h: 哈希值,数组中计算索引时会用到len: 字符串长度,通过这个值保证二进制安全val: 字符串内容,变长struct,分配时按len长度申请内存事实上字符串又可具体分为几类:IS_STR_PERSISTENT(通过malloc分配的)、IS_STR_INTERNED(php代码里写的一些字面量,比如函数名、变量值)、IS_STR_PERMANENT(永久值,生命周期大于request)、IS_STR_CONSTANT(常量)、IS_STR_CONSTANT_UNQUALIFIED,这个信息通过flag保存:zval.value-&gt;gc.u.flags,后面用到的时候再具体分析. */struct _zend_string { zend_refcounted_h gc; zend_ulong h; /* hash value */ size_t len; char val[1];}; 可以看到，结构中定义了字符串的长度 len，通过这个数值，就可以判断字符串是否已到结尾。 二进制安全我们经常会在php的手册中看到这么一句话： 此函数是二进制安全的 那二进制安全是指的什么呢？其实这要结合c语言的函数来说，我们知道c语言判定字符串结束的标志是空字符 \\0 。所以，在 c 语言中字符串函数操作到空字符时就会忽略后面的字符。 于是，在c语言中 strcmp(&quot;abc&quot;, &quot;abc\\0def&quot;) 返回的结果是 0。 但是在php中，如果一个函数是二进制安全的，那么此函数只会把空字符视为普通的字符，于是 strcmp(&quot;abc&quot;, &quot;abc\\0def&quot;) 返回的结果是 -1。 因此，二进制安全的定义就是： 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。 可以参考： php手册经常见到，什么是“二进制安全” php的二进制安全 建议更好的了解php字符串的方式，就是官方手册。 类型转换对此，官方文档有很好的说明：类型转换的判别","link":"/2019/05/31/PHP的数据类型/"},{"title":"前言","text":"这不是我写过的第一篇博客，但应该是最认真、最简单的一篇。 Hello，Poettian的博客。","link":"/2019/05/30/前言/"},{"title":"关于locale","text":"关于 locale，说白了就是为了解决程序国际化和本地化的方案。 网上其实已经给出了很好的解释，这里把参考资料罗列一下： Locale Environment Variables The LANGUAGE variable 浅析 Linux 的国际化与本地化机制 有几个点要注意一下： 优先性：LANGUAGE &gt; LC_ALL &gt; LC_* &gt; LANG 关于 LANGUAGE：set messages languages (as LC_MESSAGES) to a multi-valued value, e.g., setting it to fr:de:en will use French messages where they exist; if not, it will use German messages, and will fall back to English if neither German nor French messages are available. 设置 localeHow to Set Locales (i18n) On a Linux or Unix","link":"/2019/05/31/关于locale/"}],"tags":[{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"buffer","slug":"buffer","link":"/tags/buffer/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"locale","slug":"locale","link":"/tags/locale/"},{"name":"测试","slug":"测试","link":"/tags/测试/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"微信开发","slug":"微信开发","link":"/tags/微信开发/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"linux","slug":"linux","link":"/tags/linux/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/技术/"},{"name":"杂记","slug":"杂记","link":"/categories/杂记/"}]}