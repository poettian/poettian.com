{"pages":[{"title":"关于我","text":"👉 资深游戏迷，喜欢各种球类运动，酷爱各种电子设备，没事爱折腾，经常逛微博、偶尔去知乎、朋友圈基本只看不发、Twitter有账号。 👉 目前从事web开发工作，从12年开始学习编程，主要用 php 做后端开发，正在学习C和GO，技术上仍是菜鸟一枚，属于大龄IT男。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2019年的目标","text":"2019，年已过半，如果说还有啥目标的话，是不是有点晚？ 可是如果没有目标的话，又和咸鱼有什么区别呢？ 所以，定个小目标吧： 学完 c 的基础 写几个 c 的小程序 能够入门 PHP 源码的剖析 仅此而已！😊","link":"/2019/09/26/2019年的目标/"},{"title":"2020的小目标","text":"告别20192019年浑浑噩噩的就过去了，风平浪静。 2019年换了两份工作，目前终于算是稳定了。新公司前景不错，同事也好相处。 2019年考公之路依然艰难，本身也不感兴趣，同时自律性实在是差了些，游戏时间大于看书时间。这期间一直犹犹豫豫，想考又不想考，书看看停停，浪费了时间也无结果。 2019年值得庆贺的是落户到了天津，慢慢地也坚定了定居天津的想法。 2019年老胃病经过几番调理，终于是好了一些，但是还需要保养。胃病这玩意，真的是难，伺候大爷一样，稍不注意，就给你难受。 2019年也没有什么特别的目标。悲催… 迎来20202020年的开端恰逢疫情，人心惶惶。 天天憋在家里，虽然不用挤地铁上班，但是也难受的，关键我是一个在家就不想工作的人😭。不过，王者荣耀在用了白起之后，轻轻松松上了王者，这是一个好的开端😂。 2020的小目标凡事欲则立，不预则废。2020年应该有几个小目标，不管完成完不成，总归是有个方向。 工作方面 PHP：吃透 laravel 框架，研究使用 swoole。完成 poet 这个小框架。 C：学完并吃透 《C语言中文网教程》 和 《c primer plus》，学完《PHP 7底层设计与源码实现》，搞懂make 和 makefile，阅读《unix环境高级编程》、《unix网络编程》，尝试阅读 redis 源码 Go：学会基础语法，能写web小程序，学习和应用有关的Go框架，阅读和实践 Go 的微服务架构 学会lua，应用openresty，阅读《亿级流量网站架构核心技术》，学习kafka 学完极客时间的mysql、算法、设计模式、网络等基础知识专栏 Java有时间则看，没时间就放弃 最重要的：精通工作涉及的业务，把学习到的知识尽可能的应用在工作上 生活方面 放弃考公吧还是，把重点挪到工作上来 继续调理自己的老胃病，注意饮食，不吃太饱 平时加强锻炼，争取晚上11点之前睡觉，今年的目标是增重5斤 年底最好能把房子的事情定了 最后撸起袖子加油干吧！","link":"/2020/02/08/2020的小目标/"},{"title":"LNMP架构中的缓冲区","text":"什么是缓冲区(buffer)当执行 PHP 脚本中输出指令时，例如：header() setcookie() session_start() 以及我们常用的echo print 等，此时产生的数据会有两种行为模式选择，一是立即发送到下游SAPI；二是缓存起来等积累到一定的大小后再发送到下游SAPI，这种先将输出数据存起来等之后再发送的机制，就是缓冲区。 为什么需要缓冲区 没有缓冲区，数据立即发送给SAPI，这会使得数据以碎片形式不断传输，降低php和SAPI间通讯的效率； 没有缓冲区，你将无法对输出数据在发送前做一些操作，而缓冲区的存在使得你可以任意加工这些数据，然后选择你认为合适的时机再发送； 如果你遇到过这样的提示 “Warning: Cannot modify header information - headers already sent by (output)”，那么你可以利用缓冲区来解决。 LNMP架构下的多层缓冲区上面我们谈到的缓冲区只是指 php 脚本运行时存在于php进程内存中（到底存在于哪里我并不清楚，这只是我的理解）的缓冲区，只讨论这一个缓冲区是不够的。在LNMP架构下，每一层都存在着缓冲区： php的缓冲区 SAPI（php-fpm）的缓冲区 webserver（nginx）的缓冲区 用一张图可以很好的说明这几者间的关系： php的缓冲区php默认开启了缓冲区，大小为4096字节，这可以在配置文件 php.ini 中看到，参数项 output_buffering = 4096 即指明了缓冲区开启并设置大小为4096字节。 可设置的参数值如下： On = Enabled and buffer is unlimited. (Use with caution)Off = DisabledInteger = Enables the buffer and sets its maximum size in bytes. 当输出数据没有超过此值时，php将不断接收并缓存这些数据，而一旦超出该值，那么php就会刷新缓冲区将数据送往SAPI。这是php中默认缓冲区的行为机制。 php为开发者提供了自定义缓冲区的能力，借助 ob_start 函数，开发者可以定义新的缓冲区并可以嵌套（多次调用 ob_start），这些缓冲区将被压入栈中。当数据过来时， 会存入栈顶的缓冲区中，当数据大小超出缓冲区定义的 size 或 调用 ob_flush 和 ob_end_flush 时则将数据送到下一个缓冲区中，如此直到 php 默认的缓冲区（存在于栈底），最后送入SAPI。 SAPI的缓冲区SAPI有cli、mod_php、php-fpm等多种形式，不同的SAPI，缓冲区的存在和表现形式也大不相同。 在讲这几个SAPI的区别前，先来看 php.ini 中的一个配置项 implicit_flush 和 函数 ob_implicit_flush() 。 implicit_flush的作用，源代码已说明一切：当implicit_flush被设置为打开（值为1），一旦有任何输出写入到SAPI缓冲区层，它都会立即刷新（flush，意思是把这些数据写入到更低层，并且缓冲区会被清空），将数据送往下一层。 ob_implicit_flush 的作用和 implicit_flush 类似，当调用 ob_implicit_flush(true) 时表示打开绝对（隐式）刷送，和 设置 implicit_flush=1 作用相同；当调用 ob_implicit_flush(false) 则表示关闭绝对（隐式）刷送，和 设置 implicit_flush=0 作用相同。 下面说一下这几个SAPI的区别： cli 会将 ini 配置中的 output_buffer 选项强制设置为0，这表示禁用默认PHP输出缓冲区。所以在CLI中，默认情况下你要输出的东西会直接传递到SAPI层，除非你手动调用ob_()类函数。并且在CLI中，implicit_flush 的值也会被设置为1。 mod_php 不会缓存数据，将直接把数据送往 Apache。 php-fpm 中有一个硬编码的8k大小的缓冲区。使用 flush() 函数会刷新这个缓冲区，把数据送往webserver。 Nginx的缓冲区nginx的缓冲区机制主要由下面几个参数来控制： fastcgi_buffering on | off; 开启或关闭接收来自 FastCGI server 的响应的缓冲区。 当缓冲区被打开，nginx将立即接收来自 FastCGI server 的响应并把响应头和响应体分别存入由 fastcgi_buffer_size fastcgi_buffers 控制的缓冲区内。如果响应体积太大，部分响应内容将被写入临时文件中，临时文件的路径和大小以及每次写入临时文件的数据体大小分别由 fastcgi_temp_path fastcgi_max_temp_file_size fastcgi_temp_file_write_size 这三个配置项来决定。 如果缓冲区被关闭，那么nginx会把从 FastCGI server 接收到的响应数据立即发送给客户端。 使用 X-Accel-Buffering 这个响应头也可以控制缓冲区的打开和关闭，header('X-Accel-Buffering: no') 关闭，header('X-Accel-Buffering: yes'); 打开。 fastcgi_buffer_size size; 设置接收 FastCGI server 第一部分响应（通常包含体积很小的响应头）的缓冲区的大小。默认大小等于一个内存页，或者4k或者8k，和操作系统有关。 fastcgi_buffers number size; 设置单个连接中接收 FastCGI server 响应体的缓冲区的数量和每个缓冲区的大小。默认每个缓冲区大小等于一个内存页，或者4k或者8k，和操作系统有关。 fastcgi_busy_buffers_size size; 没看明白的一个配置项，手册上的解释为： When buffering of responses from the FastCGI server is enabled, limits the total *size* of buffers that can be busy sending a response to the client while the response is not yet fully read. In the meantime, the rest of the buffers can be used for reading the response and, if needed, buffering part of the response to a temporary file. By default, *size* is limited by the size of two buffers set by the fastcgi_buffer_sizeand fastcgi_buffers directives. 但实际上nginx并不会等数据塞满 buffer 后才发送给client，具体机制还不明确，待研究。 参考文档： PHP Streaming and Output Buffering Explained 深入理解php的输出缓冲区(output buffer) Module ngx_http_fastcgi_module PHP output buffer – bigpipe基础","link":"/2017/10/05/LNMP架构中的缓冲区/"},{"title":"PHP的数据类型","text":"学习一门语言，数据类型是必须要首先了解的。php 作为一种弱类型语言，数据类型的特点和不经意间的类型转换，往往是入坑的关键。 查看和验证数据的类型如果想查看某个表达式的值和类型，用 var_dump() 函数。 如果只是想得到一个易读懂的类型的表达方式用于调试，用 gettype() 函数。要检验某个类型，不要用 gettype()，而用 is_type 函数。 浮点数PHP 中不区分 float 和 double，如果需要高精度的计算，应该使用 BC 数学函数 或 gmp函数。 理解计算机是如何存储浮点类型数据的 字符串PHP 中的 string 的实现方式是一个由字节组成的数组再加上一个整数指明缓冲区长度。 编码字符串会被按照该脚本文件相同的编码方式来编码。我们知道，一般脚本文件都是以utf-8编码的，那么我们就来看一看字符串（英文和中文）到底在php中是如何存储的。 我们知道以utf8编码的一个字符占用1-4个字节，英文字符占用一个字节，中文字符一般占用3个字节。而由定义可知，字符串的内容是存在字节数组中的，所以字符串实际存储是以字节为单位的。 举个例子，比如：$str = 'abc严肃'。英文 abc 是单字节字符，对应的字节是 0x61 0x62 0x63，中文 严肃 是多字节字符，对应的字节分别是 0xe4 0xb8 0xa5 0xe8 0x82 0x83。（此处可参考：字符编码笔记：ASCII，Unicode 和 UTF-8） 所以字符串 $str 实际的存储如图所示： 但我们使用单字节函数时，就会得到以下结果： 123$str = 'abc严肃'echo strlen($str); // output: 9echo substr($str, 3, 1); // output：�，也许我们的本意是想取得‘严’这个字符，但是因为结果实际是取到了 0xe4 这个字节，但是无法以utf8反编码，只能是显示为乱码 其实这也解释了，为什么我们可以直接对中文字符串使用 ‘==’ 进行比较，因为比较是基于字节进行的。 与c语言字符串的区别：在c语言中，字符串是以一个空字符 \\0 结尾的，但是在php中，其值为 0（“NUL bytes”）的字节可以处于字符串任何位置。那php中如何界定字符串的结尾呢？这依赖于字符串的特殊结构： 12345678910111213/*gc: 变量引用信息,比如当前value的引用数,所有用到引用计数的变量类型都会有这个结构,3.1节会详细分析h: 哈希值,数组中计算索引时会用到len: 字符串长度,通过这个值保证二进制安全val: 字符串内容,变长struct,分配时按len长度申请内存事实上字符串又可具体分为几类:IS_STR_PERSISTENT(通过malloc分配的)、IS_STR_INTERNED(php代码里写的一些字面量,比如函数名、变量值)、IS_STR_PERMANENT(永久值,生命周期大于request)、IS_STR_CONSTANT(常量)、IS_STR_CONSTANT_UNQUALIFIED,这个信息通过flag保存:zval.value-&gt;gc.u.flags,后面用到的时候再具体分析. */struct _zend_string { zend_refcounted_h gc; zend_ulong h; /* hash value */ size_t len; char val[1];}; 可以看到，结构中定义了字符串的长度 len，通过这个数值，就可以判断字符串是否已到结尾。 二进制安全我们经常会在php的手册中看到这么一句话： 此函数是二进制安全的 那二进制安全是指的什么呢？其实这要结合c语言的函数来说，我们知道c语言判定字符串结束的标志是空字符 \\0 。所以，在 c 语言中字符串函数操作到空字符时就会忽略后面的字符。 于是，在c语言中 strcmp(&quot;abc&quot;, &quot;abc\\0def&quot;) 返回的结果是 0。 但是在php中，如果一个函数是二进制安全的，那么此函数只会把空字符视为普通的字符，于是 strcmp(&quot;abc&quot;, &quot;abc\\0def&quot;) 返回的结果是 -1。 因此，二进制安全的定义就是： 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。 可以参考： php手册经常见到，什么是“二进制安全” php的二进制安全 建议更好的了解php字符串的方式，就是官方手册。 类型转换对此，官方文档有很好的说明：类型转换的判别","link":"/2019/05/31/PHP的数据类型/"},{"title":"关于locale","text":"关于 locale，说白了就是为了解决程序国际化和本地化的方案。 网上其实已经给出了很好的解释，这里把参考资料罗列一下： Locale Environment Variables The LANGUAGE variable 浅析 Linux 的国际化与本地化机制 有几个点要注意一下： 优先性：LANGUAGE &gt; LC_ALL &gt; LC_* &gt; LANG 关于 LANGUAGE：set messages languages (as LC_MESSAGES) to a multi-valued value, e.g., setting it to fr:de:en will use French messages where they exist; if not, it will use German messages, and will fall back to English if neither German nor French messages are available. 设置 localeHow to Set Locales (i18n) On a Linux or Unix","link":"/2019/05/31/关于locale/"},{"title":"前言","text":"这不是我写过的第一篇博客，但应该是最认真、最简单的一篇。 Hello，Poettian的博客。","link":"/2017/05/30/前言/"},{"title":"linux下的文本处理","text":"文本处理（awk、grep、sed、cut）本小节引用文章：【玩转linux系列】awk、grep、sed awk、grep、sed是linux操作文本的三大利器，也是必须掌握的linux命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。grep更适合单纯的查找或匹配文本，sed更适合编辑匹配到的文本，awk更适合格式化文本，对文本进行较复杂格式处理。 实验数据1234# test.log20170102 admin,password Open20170801 nmask,nmask close20180902 nm4k,test filter awk命令格式123awk [选项参数] 'script' var=value file(s)或awk [选项参数] -f scriptfile var=value file(s) awk是以列为划分计数的，$0 表示所有列，$1 表示第一列，$2 表示第二列。 常用参数 -F 指定输入文件折分隔符，如-F: -v 赋值一个用户定义变量，如-va=1 -f 从脚本文件中读取awk命令 分隔符12345678# 按空格分割awk '{print $1,$3}' test.log# 使用“,”分割awk -F , '{print $1,$2}' test.log# 使用多个分隔符，先使用空格分割，然后对分割结果再使用”,”分割awk -F '[ ,]' '{print $1,$2,$3}' test.log #注意逗号前面有一个空格 设置变量1234awk -v a=1 -v b=s '{print $1,$1+a,$1b}' test.log# 字符串拼接，用\"awk -v a=\\\" '{print a\"\"$0\"\"a}' test.log 逻辑判断 运算符 描述 = += -= *= /= %= ^= **= 赋值 ?: C条件表达式 || 逻辑或 &amp;&amp; 逻辑与 ~ ~! 匹配正则表达式和不匹配正则表达式 &lt; &lt;= &gt; &gt;= != == 关系运算符 空格 连接 + - 加，减 * / % 乘，除与求余 + - ! 一元加，减和逻辑非 ^ *** 求幂 ++ – 增加或减少，作为前缀或后缀 $ 字段引用 in 数组成员 12345678# 输出第一列为20170801的记录awk '$1==20170801 {print}' test.log# 输出第二列不是nmask,nmask的记录awk '$2!=\"nmask,nmask\" {print}' test.log# 组合使用awk '$1==20170801 &amp;&amp; $2!=\"nmask,nmask\" {print $1,$2,$3}' test.log 内建变量 变量 描述 $n 当前记录的第n个字段，字段间由FS分隔 $0 完整的输入记录 ARGC 命令行参数的数目 ARGIND 命令行中当前文件的位置(从0开始算) ARGV 包含命令行参数的数组 CONVFMT 数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组 ERRNO 最后一个系统错误的描述 FIELDWIDTHS 字段宽度列表(用空格键分隔) FILENAME 当前文件名 FNR 各文件分别计数的行号 FS 字段分隔符(默认是任何空格) IGNORECASE 如果为真，则进行忽略大小写的匹配 NF 一条记录的字段的数目 NR 已经读出的记录数，就是行号，从1开始 OFMT 数字的输出格式(默认值是%.6g) OFS 输出记录分隔符（输出换行符），输出时用指定的符号代替换行符 ORS 输出记录分隔符(默认值是一个换行符) RLENGTH 由match函数所匹配的字符串的长度 RS 记录分隔符(默认是一个换行符) RSTART 由match函数所匹配的字符串的第一个位置 SUBSEP 数组下标分隔符(默认值是/034) 1awk 'BEGIN{printf \"%4s %4s %4s %4s %4s %4s %4s %4s %4s\\n\",\"FILENAME\",\"ARGC\",\"FNR\",\"FS\",\"NF\",\"NR\",\"OFS\",\"ORS\",\"RS\";printf \"---------------------------------------------\\n\"} {printf \"%4s %4s %4s %4s %4s %4s %4s %4s %4s\\n\",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}' test.log 使用正则12345678910111213# 输出第二列中包含nm开头的所有记录awk '$2 ~ /nm.*/ {print}' test.log# 输出包含2017开头的记录awk '/2017.*/ {print}' test.log # 注意：这里没有～，因为没有指定是哪一列# 忽略大小写{INGORECASE=1}awk '{INGORECASE=1} /nmask/ {print}' test.log# 匹配取反 !~awk '$2 !~ /nm.*/ {print}' test.log# 数组和正则捕获的强大用法 内置函数12345678# substr字符串截取, 截取第一列的第一到第四个字符awk '{print substr($1, 1, 4)}' test.log# split切分字符串, 以逗号分隔第2列的数据，并输出分别输出第2列的内容awk '{split($2, a, \",\");print a[1],a[2]}'# gsub替换, 将第2列中的nmask替换成nMaskawk '{gsub(\"nmask\", \"nMask\", $2);print}' grepLinux grep命令用于查找文件里符合条件的字符串。 12345# 递归查询grep -r nmask /etc/ #查看/etc目录下内容包含nmask的文件# 查询取反grep -v test test.log sedLinux sed命令是利用script来处理文本文件。 命令格式1sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件] 参数 -e &lt;script&gt; 或 –expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。 -f &lt;script文件&gt; 或 –file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。 -h或–help 显示帮助。 -n或–quiet或–silent 仅显示script处理后的结果。 -V或–version 显示版本信息。 动作说明 a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚； i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～ s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ 插入操作123456789101112131415161718192021222324252627282930313233343536# 在test.log文件的第3行后插入一行，内容为nmasksed -e 3a\\nmask test.log # 注意在使用a, c or i时要在后面使用\\或者sed -e '3a nmask' test.log# -e 可以省略sed 3a\\nmask test.log或者sed '3a nmask' test.log# 如果有空格sed 3a\\nmask\\ sdg\\ sdg test.log或者sed '3a nmask sdg sdg' test.log# 删除2~3行sed 2,3d test.log# 替换第二行为“No 2 number”sed '2c No 2-5 number' test.log# 搜索有\"nmask\"关键字的行 sed -n '/nmask/p' test.log# 搜索有\"nmask\"关键字的行并删除sed '/nmask/d' test.log# 数据的搜寻并替换sed 's/要被取代的字串/新的字串/g' FILE# 直接修改文件内容(危险动作)sed -i 's/\\.$/\\!/g' regular_express.txt # 利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !# 利用 sed 直接在 regular_express.txt 最后一行加入『# This is a test』# 由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增『# This is a test』！sed -i '$a # This is a test' regular_express.txt cutLinux cut命令用于显示每行从开头算起 num1 到 num2 的文字。 命令格式123cut [-bn] [file]cut [-c] [file]cut [-df] [file] 参数 -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。 -c ：以字符为单位进行分割。 -d ：自定义分隔符，默认为制表符。 -f ：与-d一起使用，指定显示哪个区域。 -n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 用法1cut -d ':' -f1 /etc/passwd 管道过滤器（xargs）简介xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。 它擅长将标准输入数据转换成命令行参数，xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。 xargs也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。 xargs的默认命令是echo，空格是默认定界符。这意味着通过管道传递给xargs的输入将会包含换行和空白，不过通过xargs的处理，换行和空白将被空格取代。 xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令 命令格式1somecommand |xargs -item command 常用参数 -n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。 -d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符 用法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# cat test.txta b c d e f gh i j k l m no p qr s tu v w x y z# 多行输入单行输出：# cat test.txt | xargsa b c d e f g h i j k l m n o p q r s t u v w x y z# -n 选项多行输出：# cat test.txt | xargs -n3a b cd e fg h ij k lm n op q rs t uv w xy z# -d 选项可以自定义一个定界符：# echo \"nameXnameXnameXname\" | xargs -dXname name name name# 读取 stdin，将格式化后的参数传递给命令# xargs的一个选项-I，使用-I指定一个替换字符串{}，这个字符串在xargs扩展时会被替换掉，当-I与xargs结合使用，每一个参数命令都会被执行一次cat arg.txt | xargs -I {} ./sk.sh -p {} -l或者cat arg.txt | xargs -i ./sk.sh -p {} -l# 输出：-p aaa -l-p bbb -l-p ccc -l# 复制所有图片文件到 /data/images 目录下ls *.jpg | xargs -n1 -I {} cp {} /data/images或者ls *.jpg | xargs -n1 -i cp {} /data/images# 参数说明-I R same as --replace=R (R must be specified)-i,--replace=[R] Replace R in initial arguments with names read from standard input. If R is unspecified, assume {}# 再看一个例子sudo apt list | grep php | awk -F '/' '/^php7\\.2/ {print $1}' | xargs# xargs结合find使用# 用rm 删除太多的文件时候，可能得到一个错误信息：/bin/rm Argument list too long. 用xargs去避免这个问题：find . -type f -name \"*.log\" -print0 | xargs -0 rm -f# 查找所有的jpg 文件，并且压缩它们：find . -type f -name \"*.jpg\" -print | xargs tar -czvf images.tar.gz","link":"/2018/09/04/linux下的文本处理/"},{"title":"tmux的简单使用","text":"本文参考和引自： Tmux使用教程、Tmux使用手册 简介命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。用户与计算机的这种临时的交互，称为一次”会话”（session）。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。 Tmux 的出现解决了上面的问题。 Tmux功能多会话、多窗口、分屏 它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 它可以让新窗口”接入”已经存在的会话。 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 它还支持窗口任意的垂直和水平拆分。 为了更好的理解这三个概念，可以参考如下的图示： 保护现场即使命令行的工作只进行到一半，关闭终端后还可以重新进入到操作现场，继续工作。对于ssh远程连接而言，即使网络不稳定也没有关系，掉线后重新连接，可以直奔现场，之前运行中的任务，依旧在跑，就好像从来没有离开过一样；特别是在远程服务器上运行耗时的任务，tmux可以帮你一直保持住会话。如此一来，你就可以随时随地放心地进行移动办公，只要你附近的计算机装有tmux（没有你也可以花几分钟装一个），你就能继续刚才的工作。 会话分享（适用结对编程和远程教学）将 tmux 会话的地址分享给他人，这样他们就可以通过 SSH 接入该会话。如果你要给同事演示远程服务器的操作，他不必直勾勾地盯着你的屏幕，借助tmux，他完全可以进入到你的会话，然后静静地看着他桌面上你风骚的键盘走位，只要他愿意，甚至还可以录个屏。 安装12345678# Ubuntu 或 Debian$ sudo apt-get install tmux# CentOS 或 Fedora$ sudo yum install tmux# Mac$ brew install tmux 会话管理新建会话12tmux # 新建一个无名称的会话tmux new -s demo # 新建一个名称为demo的会话 断开会话12tmux detach # 断开当前会话，会话在后台运行# 快捷键 ctrl+b d 重连会话12tmux attach # 默认进入第一个会话tmux attach -t demo # 进入到名称为demo的会话 关闭会话12tmux kill-session -t demo # 关闭demo会话tmux kill-server # 关闭服务器，所有的会话都将关闭 常用快捷键系统和会话 前缀 指令 描述 Ctrl+b ? 显示快捷键帮助文档 Ctrl+b d 断开当前会话 Ctrl+b D 选择要断开的会话 Ctrl+b Ctrl+z 挂起当前会话 Ctrl+b r 强制重载当前会话 Ctrl+b s 显示会话列表用于选择并切换 Ctrl+b : 进入命令行模式，此时可直接输入ls等命令 Ctrl+b [ 进入复制模式，按q退出 Ctrl+b ] 粘贴复制模式中复制的文本 Ctrl+b ~ 列出提示信息缓存 窗口 前缀 指令 描述 Ctrl+b c 新建窗口 Ctrl+b &amp; 关闭当前窗口（关闭前需输入y or n确认） Ctrl+b 0~9 切换到指定窗口 Ctrl+b p 切换到上一窗口 Ctrl+b n 切换到下一窗口 Ctrl+b w 打开窗口列表，用于且切换窗口 Ctrl+b , 重命名当前窗口 Ctrl+b . 修改当前窗口编号（适用于窗口重新排序） Ctrl+b f 快速定位到窗口（输入关键字匹配窗口名称） 面板 前缀 指令 描述 Ctrl+b - 当前面板上下一分为二，下侧新建面板 Ctrl+b ｜ 当前面板左右一分为二，右侧新建面板 Ctrl+b x 关闭当前面板（关闭前需输入y or n确认） Ctrl+b z 最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增） Ctrl+b ! 将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效） Ctrl+b ; 切换到最后一次使用的面板 Ctrl+b q 显示面板编号，在编号消失前输入对应的数字可切换到相应的面板 Ctrl+b { 向前置换当前面板 Ctrl+b } 向后置换当前面板 Ctrl+b Ctrl+o 顺时针旋转当前窗口中的所有面板 Ctrl+b 方向键 移动光标切换面板 Ctrl+b o 选择下一面板 Ctrl+b 空格键 在自带的面板布局中循环切换 Ctrl+b Alt+方向键 以5个单元格为单位调整当前面板边缘 Ctrl+b Ctrl+方向键 以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖） Ctrl+b t 显示时钟 可配置性tmux的用户级配置文件为 ~/.tmux.conf（没有的话就创建一个）。 贴一下我自己 mac 上的配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 配置 24-bit True-color(Tc), more info in this PR:# https://github.com/tmux/tmux/pull/112set -g default-terminal \"screen-256color\"set -ga terminal-overrides \",*256col*:Tc\" # 这句是关键# 配置prefixset -g prefix `# 解除C-b的绑定unbind C-b# 绑定快捷键，重新加载配置文件bind r source-file ~/.tmux.conf \\; display-message \"Config reloaded..\"# 支持鼠标选择窗口，调节窗口大小#set -g mouse onset -sg escape-time 1# 窗口号和窗口分割号都以1开始（默认从0开始）set -g base-index 1setw -g pane-base-index 1# 监视窗口信息，如有内容变动，进行提示setw -g monitor-activity onset -g visual-activity on# 绑定hjkl键为面板切换的上下左右键bind -r k select-pane -U # 绑定k为↑bind -r j select-pane -D # 绑定j为↓bind -r h select-pane -L # 绑定h为←bind -r l select-pane -R # 绑定l为→# 新增面板unbind '\"'bind - splitw -v -c '#{pane_current_path}' # 垂直方向新增面板，默认进入当前目录unbind %bind | splitw -h -c '#{pane_current_path}' # 水平方向新增面板，默认进入当前目录# 启动鼠标支持set -g mouse on# 插件run-shell ~/.tmux/plugins/tmux-resurrect/resurrect.tmux 有一点需要注意的是，当启动鼠标支持时，iterm2 自带的双击选中和前后鼠标点击加shift选中会失效，此时需要同时按下 Alt 键，才会生效。","link":"/2020/02/08/tmux的简单使用/"}],"tags":[{"name":"测试","slug":"测试","link":"/tags/测试/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"微信开发","slug":"微信开发","link":"/tags/微信开发/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"tudo","slug":"tudo","link":"/tags/tudo/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"locale","slug":"locale","link":"/tags/locale/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"tools","slug":"tools","link":"/tags/tools/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/技术/"},{"name":"杂记","slug":"杂记","link":"/categories/杂记/"},{"name":"工具","slug":"工具","link":"/categories/工具/"}]}